// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"text/template"
)

var dataPath string
var outputPath string

func main() {
	flag.StringVar(&dataPath, "dataPath", "", "Input data file with unicode test cases")
	flag.StringVar(&outputPath, "outputPath", "", "Output path for generated go file")
	flag.Parse()

	if len(dataPath) < 1 {
		log.Fatalf("Must specify input data path")
	}

	if len(outputPath) < 1 {
		log.Fatalf("Must specify output path")
	}

	fmt.Printf("Generating %s from %s\n", outputPath, dataPath)

	testCases, err := parseDataFile(dataPath)
	if err != nil {
		log.Fatalf("error loading test cases from data file at %s\n: %v", dataPath, err)
	}

	if err := writeOutputFile(outputPath, testCases); err != nil {
		log.Fatalf("error generating output file %s: %v", outputPath, err)
	}
}

type TestCase struct {
	CodePoints  []rune
	BreakPoints []bool
	Description string
}

func parseDataFile(path string) ([]TestCase, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	testCases := make([]TestCase, 0)

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		hasTestCase, tc, err := parseLine(line)
		if err != nil {
			return nil, err
		}

		if hasTestCase {
			testCases = append(testCases, tc)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return testCases, nil
}

var DESCRIPTION_RE = regexp.MustCompile(`^.+#\s*(.+)$`)
var BREAKPOINT_RE = regexp.MustCompile(`([รทร])\s*([0-9A-Z]+)`)

func parseLine(line string) (bool, TestCase, error) {
	if len(line) == 0 || line[0] == '#' {
		return false, TestCase{}, nil
	}

	descriptionMatch := DESCRIPTION_RE.FindStringSubmatch(line)
	if descriptionMatch == nil {
		return false, TestCase{}, nil
	}
	description := descriptionMatch[1]

	breakpointMatches := BREAKPOINT_RE.FindAllStringSubmatch(line, -1)

	tc := TestCase{
		CodePoints:  make([]rune, 0, len(breakpointMatches)),
		BreakPoints: make([]bool, 0, len(breakpointMatches)),
		Description: description,
	}

	for _, m := range breakpointMatches {
		breakResult, hexCode := m[1], m[2]
		codePoint, err := strconv.ParseUint(hexCode, 16, 32)
		if err != nil {
			return false, TestCase{}, err
		}

		tc.CodePoints = append(tc.CodePoints, rune(codePoint))
		tc.BreakPoints = append(tc.BreakPoints, bool(breakResult == "รท"))
	}

	return true, tc, nil
}

func writeOutputFile(path string, testCases []TestCase) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	tmpl, err := template.New("output").Parse(`
	// This file is generated by gen_tests.go. DO NOT EDIT.

	package breaks

	import (
		"strconv"
		"testing"

		"github.com/stretchr/testify/assert"
	)

	func TestGraphemeBreakCases(t *testing.T) {
		testCases := []struct{
			codePoints  []rune
			breakPoints []bool
			description string
		}{
			{{ range . -}}
			{
				codePoints: {{ printf "%#v" .CodePoints }},
				breakPoints: {{ printf "%#v" .BreakPoints }},
				description: "{{ .Description }}",
			},
			{{ end }}
		}

		for i, tc := range testCases {
			t.Run(strconv.FormatInt(int64(i), 10), func(t *testing.T) {
				finder := NewGraphemeClusterBreakFinder()
				breakPoints := make([]bool, 0)
				for _, c := range tc.codePoints {
					bp := finder.ProcessCharacter(c)
					breakPoints = append(breakPoints, bp)
				}
				assert.Equal(t, tc.breakPoints, breakPoints, tc.description)
			})
		}
	}
	`)

	if err != nil {
		return err
	}

	return tmpl.Execute(file, testCases)
}
