// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

var prefix string
var dataPaths stringArrayFlags
var propertyNames stringArrayFlags
var outputPath string

func main() {
	flag.StringVar(&prefix, "prefix", "", "Prefix for symbols in the generated go file")
	flag.Var(&dataPaths, "dataPath", "Input data file with unicode property definitions")
	flag.Var(&propertyNames, "propertyName", "Unicode properties to include in the generated go file")
	flag.StringVar(&outputPath, "outputPath", "", "Output path for the generated go file")
	flag.Parse()

	if len(prefix) < 1 {
		log.Fatalf("Must specify prefix")
	}

	if len(dataPaths) < 1 {
		log.Fatalf("Must specify at least one input data path")
	}

	if len(propertyNames) < 1 {
		log.Fatalf("Must specify at least one property name")
	}

	if len(outputPath) < 1 {
		log.Fatalf("Must specify output path")
	}

	propFilter := NewPropFilter(propertyNames)

	fmt.Printf("Generating %s from %s\n", outputPath, dataPaths.String())

	ranges := make([]parsedRange, 0)
	for _, path := range dataPaths {
		var err error
		ranges, err = parseDataFile(path, propFilter, ranges)
		if err != nil {
			log.Fatalf("error parsing data file %s: %v", path, err)
		}
	}

	runeMap, err := buildRuneMap(ranges)
	if err != nil {
		log.Fatalf("error building rune map: %v", err)
	}

	propNames := uniquePropNames(runeMap)

	if err := writeOutputFile(prefix, outputPath, propNames, runeMap); err != nil {
		log.Fatalf("error generating output file %s: %v", outputPath, err)
	}
}

type stringArrayFlags []string

func (f *stringArrayFlags) String() string {
	return fmt.Sprintf("[%s]", strings.Join(*f, ", "))
}

func (f *stringArrayFlags) Set(s string) error {
	*f = append(*f, s)
	return nil
}

type parsedRange struct {
	start    uint64
	end      uint64
	propName string
}

type propFilter struct {
	filterProps map[string]struct{}
}

func NewPropFilter(includeProps []string) *propFilter {
	filterProps := make(map[string]struct{}, 0)
	for _, p := range includeProps {
		filterProps[p] = struct{}{}
	}
	return &propFilter{filterProps}
}

func (f *propFilter) CheckAllowed(prop string) bool {
	_, ok := f.filterProps[prop]
	return ok
}

func parseDataFile(dataPath string, propFilter *propFilter, ranges []parsedRange) ([]parsedRange, error) {
	file, err := os.Open(dataPath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		hasRange, rng, err := parseLine(line, propFilter)
		if err != nil {
			return nil, err
		}

		if hasRange {
			ranges = append(ranges, rng)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return ranges, nil
}

var LINE_RE = regexp.MustCompile(`^([A-Z0-9]+)(..[A-Z0-9]+)?\s*;\s*([A-z]+)`)

func parseLine(line string, propFilter *propFilter) (bool, parsedRange, error) {
	match := LINE_RE.FindStringSubmatch(line)
	if match == nil {
		return false, parsedRange{}, nil
	}

	propName := match[3]
	if !propFilter.CheckAllowed(propName) {
		return false, parsedRange{}, nil
	}

	startCodepoint, err := strconv.ParseUint(match[1], 16, 32)
	if err != nil {
		return false, parsedRange{}, err
	}

	var endCodepoint uint64
	endMatch := match[2]
	if len(endMatch) == 0 {
		endCodepoint = startCodepoint
	} else {
		endHex := endMatch[2:] // remove ".." prefix
		endCodepoint, err = strconv.ParseUint(endHex, 16, 32)
		if err != nil {
			return false, parsedRange{}, err
		}
	}

	rng := parsedRange{
		start:    startCodepoint,
		end:      endCodepoint,
		propName: propName,
	}

	return true, rng, nil
}

func buildRuneMap(parsedRanges []parsedRange) (map[rune]string, error) {
	result := make(map[rune]string, 0)

	for _, rng := range parsedRanges {
		for c := rng.start; c <= rng.end; c++ {
			if _, ok := result[rune(c)]; ok {
				return nil, fmt.Errorf("Duplicate rune detected: %d", c)
			}
			result[rune(c)] = rng.propName
		}
	}

	return result, nil
}

func uniquePropNames(runeMap map[rune]string) []string {
	set := make(map[string]struct{}, 0)
	for _, propName := range runeMap {
		set[propName] = struct{}{}
	}

	result := make([]string, 0, len(set))
	for propName, _ := range set {
		result = append(result, propName)
	}

	sort.Strings(result)
	return result
}

func writeOutputFile(prefix string, path string, propNames []string, runeMap map[rune]string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	tmpl, err := template.New("output").Parse(`
	// This file is generated by gen_props.go. DO NOT EDIT.

	package breaks

	{{ $input := . }}

	type {{ $input.Prefix }}Prop byte

	const (
		{{ $input.Prefix }}PropOther = {{ $input.Prefix }}Prop(iota)
		{{ range $propName := $input.PropNames -}}
		{{ $input.Prefix }}Prop{{ $propName }}
		{{ end  }}
	)

	var {{ $input.Prefix }}PropRuneMap = map[rune]{{ $input.Prefix }}Prop{
		{{ range $rune, $propName := $input.RuneMap -}}
		{{ $rune }}: {{ $input.Prefix }}Prop{{ $propName }},
		{{ end }}
	}

	func {{ $input.Prefix }}PropForRune(r rune) {{ $input.Prefix }}Prop {
		prop, ok := {{ $input.Prefix }}PropRuneMap[r]
		if ok {
			return prop
		} else {
			return {{ $input.Prefix }}PropOther
		}
	}
	`)
	if err != nil {
		return err
	}

	return tmpl.Execute(file, map[string]interface{}{
		"Prefix":    prefix,
		"PropNames": propNames,
		"RuneMap":   runeMap,
	})
}
