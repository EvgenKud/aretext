// +build ignore

package main

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

const apiJsonPath string = "api.json"
const serverBrokerOutputPath = "broker.go"
const serverMessageOutputPath = "message.go"

func main() {
	apiSpec, err := LoadApiSpec(apiJsonPath)
	if err != nil {
		log.Fatalf("Could not load API spec from '%s': %v", apiJsonPath, err)
	}

	fmt.Printf("Generating %s from %s\n", serverMessageOutputPath, apiJsonPath)
	if err := apiSpec.GenerateServerMessages(serverMessageOutputPath); err != nil {
		log.Fatalf("Could not generate server messages: %v", err)
	}

	fmt.Printf("Generating %s from %s\n", serverBrokerOutputPath, apiJsonPath)
	if err := apiSpec.GenerateServerBroker(serverBrokerOutputPath); err != nil {
		log.Fatalf("Could not generate server broker: %v", err)
	}
}

type ApiSpec struct {
	Version   string     // MD5 hash of canonicalized JSON
	Messages  []Message  `json:"messages"`
	Endpoints []Endpoint `json:"endpoints"`
}

type Endpoint struct {
	Name            string `json:"name"`
	Description     string `json:"description"`
	TaskConstructor string `json:"task_constructor"`
	RequestMsg      string `json:"request_msg"`
	ResponseMsg     string `json:"response_msg"`
}

type Message struct {
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Fields      []Field `json:"fields"`
}

type FieldType string

const (
	FieldTypeString = "string"
	FieldTypeBool   = "bool"
)

type Field struct {
	Name        string      `json:"name"`
	Type        FieldType   `json:"type"`
	Description string      `json:"description"`
	Default     interface{} `json:"default"`
}

func LoadApiSpec(path string) (*ApiSpec, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, errors.Wrapf(err, "os.Open()")
	}
	defer f.Close()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, errors.Wrapf(err, "ioutil.ReadAll()")
	}

	var apiSpec ApiSpec
	if err := json.Unmarshal(data, &apiSpec); err != nil {
		return nil, errors.Wrapf(err, "json.Unmarshal()")
	}

	jsonBytes, err := json.Marshal(apiSpec)
	if err != nil {
		return nil, errors.Wrapf(err, "json.Marshal()")
	}

	apiSpec.Version = fmt.Sprintf("%x", md5.Sum(jsonBytes))

	return &apiSpec, nil
}

func (spec *ApiSpec) GenerateServerMessages(path string) error {
	tmplStr := `// This file is generated by gen.go.  DO NOT EDIT.

package rpc

{{ range $msg := .Spec.Messages }}
// {{ $msg.Description }}
type {{ $msg.Name | GoSymbol }} struct {
	{{ range $field := $msg.Fields }}
	// {{ $field.Description }}
	{{ $field.Name | GoSymbol }} {{ $field.Type | GoType }} {{ $field.Name | GoJsonTag }}
	{{ end }}
}
{{ end }}
`

	tmplFuncs := template.FuncMap{
		"GoSymbol":  GoSymbol,
		"GoType":    GoType,
		"GoJsonTag": GoJsonTag,
	}
	tmpl, err := template.New("serverMessage").Funcs(tmplFuncs).Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.New()")
	}

	return spec.generate(path, tmpl)
}

func (spec *ApiSpec) GenerateServerBroker(path string) error {
	tmplStr := `// This file is generated by gen.go.  DO NOT EDIT.

package rpc

import (
	"encoding/json"
	"log"

	"github.com/pkg/errors"
)

// TaskBroker translates RPC requests/responses to executable tasks.
// It implements AsyncExecutor so a server can schedule tasks for asynchronous execution.
// It also implements TaskPoller so tasks can be retrieved and executed.
type TaskBroker struct {
	taskChan chan Task
}

// NewTaskBroker creates a new task broker.
func NewTaskBroker() *TaskBroker {
	return &TaskBroker{
		taskChan: make(chan Task, 1),
	}
}

// ApiVersion returns the API version supported by the broker.
// All requests sent to the broker MUST conform to this API version.
// This implements AsyncExecutor#ApiVersion().
func (e *TaskBroker) ApiVersion() string {
	return "{{ .Spec.Version }}"
}

// ExecuteAsync implements AsyncExecutor#ExecuteAsync().
func (e *TaskBroker) ExecuteAsync(endpoint string, data []byte) (chan []byte, error) {
	switch endpoint {
		{{ range $endpoint := .Spec.Endpoints -}}
		case "{{ $endpoint.Name }}":
			var msg {{ $endpoint.RequestMsg | GoSymbol }}
			if err := json.Unmarshal(data, &msg); err != nil {
				return nil, errors.Wrapf(err, "json.Unmarshal()")
			}

			replyMsgChan := make(chan {{ $endpoint.ResponseMsg | GoSymbol }}, 0)
			task, err := {{ $endpoint.TaskConstructor }}(msg, replyMsgChan)
			if err != nil {
				return nil, errors.Wrapf(err, "{{ $endpoint.TaskConstructor }}()")
			}

			replyChan := make(chan []byte, 0)
			go func() {
				defer close(replyChan)
				replyMsg := <- replyMsgChan
				replyData, err := json.Marshal(replyMsg)
				if err != nil {
					log.Printf("Could not serialize reply msg: %v\n", err)
					return
				}
				replyChan <- replyData
			}()

			e.taskChan <- task
			return replyChan, nil
		{{ end }}

		default:
			return nil, errors.New("Invalid endpoint")
	}
}

// PollTask implements TaskPoller#PollTask().
func (e *TaskBroker) PollTask() Task {
	return <-e.taskChan
}
`

	tmplFuncs := template.FuncMap{"GoSymbol": GoSymbol}
	tmpl, err := template.New("serverBroker").Funcs(tmplFuncs).Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.New()")
	}

	return spec.generate(path, tmpl)
}

func (spec *ApiSpec) generate(path string, tmpl *template.Template) error {
	f, err := os.Create(path)
	if err != nil {
		return errors.Wrapf(err, "os.Create()")
	}
	defer f.Close()

	return tmpl.Execute(f, map[string]interface{}{
		"Spec": spec,
	})
}

func GoSymbol(s string) string {
	if len(s) == 0 {
		return s
	}

	// Replace underscores with spaces (we'll remove the spaces later).
	s = strings.ReplaceAll(s, "_", " ")

	// Capitalize the first letter of each word.
	s = strings.Title(s)

	// Remove the spaces.
	s = strings.ReplaceAll(s, " ", "")

	return s
}

func GoType(fieldType FieldType) string {
	switch fieldType {
	case FieldTypeString:
		return "string"
	case FieldTypeBool:
		return "bool"
	default:
		log.Fatalf("Unrecognized type: %s", fieldType)
		return ""
	}
}

func GoJsonTag(name string) string {
	return fmt.Sprintf("`json:\"%s\"`", name)
}
