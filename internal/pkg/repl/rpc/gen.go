// +build ignore

package main

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

const apiJsonPath string = "api.json"
const serverBrokerOutputPath = "broker.go"
const serverMessageOutputPath = "message.go"
const clientOutputPath = "../../../../pyaretext/api/rpcclient.py"

func main() {
	apiSpec, err := LoadApiSpec(apiJsonPath)
	if err != nil {
		log.Fatalf("Could not load API spec from '%s': %v", apiJsonPath, err)
	}

	fmt.Printf("Generating %s from %s\n", serverMessageOutputPath, apiJsonPath)
	if err := apiSpec.GenerateServerMessages(serverMessageOutputPath); err != nil {
		log.Fatalf("Could not generate server messages: %v", err)
	}

	fmt.Printf("Generating %s from %s\n", serverBrokerOutputPath, apiJsonPath)
	if err := apiSpec.GenerateServerBroker(serverBrokerOutputPath); err != nil {
		log.Fatalf("Could not generate server broker: %v", err)
	}

	fmt.Printf("Generating %s from %s\n", clientOutputPath, apiJsonPath)
	if err := apiSpec.GenerateClient(clientOutputPath); err != nil {
		log.Fatalf("Could not generate client: %v", err)
	}
}

type ApiSpec struct {
	Version   string     // MD5 hash of canonicalized JSON
	Messages  []Message  `json:"messages"`
	Endpoints []Endpoint `json:"endpoints"`
}

type Endpoint struct {
	Name            string `json:"name"`
	Description     string `json:"description"`
	TaskConstructor string `json:"task_constructor"`
	RequestMsg      string `json:"request_msg"`
	ResponseMsg     string `json:"response_msg"`
}

type Message struct {
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Fields      []Field `json:"fields"`
}

type FieldType string

const (
	FieldTypeString = "string"
	FieldTypeBool   = "bool"
)

type Field struct {
	Name        string      `json:"name"`
	Type        FieldType   `json:"type"`
	Description string      `json:"description"`
	Default     interface{} `json:"default"`
}

func LoadApiSpec(path string) (*ApiSpec, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, errors.Wrapf(err, "os.Open()")
	}
	defer f.Close()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, errors.Wrapf(err, "ioutil.ReadAll()")
	}

	var apiSpec ApiSpec
	if err := json.Unmarshal(data, &apiSpec); err != nil {
		return nil, errors.Wrapf(err, "json.Unmarshal()")
	}

	jsonBytes, err := json.Marshal(apiSpec)
	if err != nil {
		return nil, errors.Wrapf(err, "json.Marshal()")
	}

	apiSpec.Version = fmt.Sprintf("%x", md5.Sum(jsonBytes))

	return &apiSpec, nil
}

func (spec *ApiSpec) GenerateServerMessages(path string) error {
	tmplStr := `// This file is generated by gen.go.  DO NOT EDIT.

package rpc

{{ range $msg := .Spec.Messages }}
// {{ $msg.Description }}
type {{ $msg.Name | GoSymbol }} struct {
	{{ range $field := $msg.Fields }}
	// {{ $field.Description }}
	{{ $field.Name | GoSymbol }} {{ $field.Type | GoType }} {{ $field.Name | GoJsonTag }}
	{{ end }}
}
{{ end }}
`

	tmplFuncs := template.FuncMap{
		"GoSymbol":  GoSymbol,
		"GoType":    GoType,
		"GoJsonTag": GoJsonTag,
	}
	tmpl, err := template.New("serverMessage").Funcs(tmplFuncs).Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.New()")
	}

	return spec.generate(path, tmpl)
}

func (spec *ApiSpec) GenerateServerBroker(path string) error {
	tmplStr := `// This file is generated by gen.go.  DO NOT EDIT.

package rpc

import (
	"encoding/json"
	"log"

	"github.com/pkg/errors"
)

// TaskBroker translates RPC requests/responses to executable tasks.
// It implements AsyncExecutor so a server can schedule tasks for asynchronous execution.
// It also implements TaskSource so tasks can be retrieved and executed.
type TaskBroker struct {
	taskChan chan Task
}

// NewTaskBroker creates a new task broker.
func NewTaskBroker() *TaskBroker {
	return &TaskBroker{
		taskChan: make(chan Task, 1),
	}
}

// ApiVersion returns the API version supported by the broker.
// All requests sent to the broker MUST conform to this API version.
// This implements AsyncExecutor#ApiVersion().
func (e *TaskBroker) ApiVersion() string {
	return "{{ .Spec.Version }}"
}

// ExecuteAsync implements AsyncExecutor#ExecuteAsync().
func (e *TaskBroker) ExecuteAsync(endpoint string, data []byte) (chan []byte, error) {
	switch endpoint {
		{{ range $endpoint := .Spec.Endpoints -}}
		case "{{ $endpoint.Name }}":
			var msg {{ $endpoint.RequestMsg | GoSymbol }}
			if err := json.Unmarshal(data, &msg); err != nil {
				return nil, errors.Wrapf(err, "json.Unmarshal()")
			}

			replyMsgChan := make(chan {{ $endpoint.ResponseMsg | GoSymbol }}, 0)
			task, err := {{ $endpoint.TaskConstructor }}(msg, replyMsgChan)
			if err != nil {
				return nil, errors.Wrapf(err, "{{ $endpoint.TaskConstructor }}()")
			}

			replyChan := make(chan []byte, 0)
			go func() {
				defer close(replyChan)
				replyMsg := <- replyMsgChan
				replyData, err := json.Marshal(replyMsg)
				if err != nil {
					log.Printf("Could not serialize reply msg: %v\n", err)
					return
				}
				replyChan <- replyData
			}()

			e.taskChan <- task
			return replyChan, nil
		{{ end }}

		default:
			return nil, errors.New("Invalid endpoint")
	}
}

// TaskChan implements TaskSource#TaskChan().
func (e *TaskBroker) TaskChan() chan Task {
	return e.taskChan
}
`

	tmplFuncs := template.FuncMap{"GoSymbol": GoSymbol}
	tmpl, err := template.New("serverBroker").Funcs(tmplFuncs).Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.New()")
	}

	return spec.generate(path, tmpl)
}

func (spec *ApiSpec) GenerateClient(path string) error {
	tmplStr := `# This file is generated by gen.go.  DO NOT EDIT.

from __future__ import annotations
from dataclasses import dataclass, asdict
import json
import os
from socket import socket
from typing import Dict
from urllib.parse import urlparse


API_VERSION = "{{ .Spec.Version }}"


class Client:
	"""A client for sending RPCs to the aretext API."""

	def __init__(self, addr: str, api_key: str):
		self._socket = socket()
		self._api_key = api_key
		parsed_addr = urlparse("tcp://{}".format(addr))
		self._socket.connect((parsed_addr.hostname, parsed_addr.port))

	def disconnect(self):
		self._socket.close()

	{{ range $endpoint := .Spec.Endpoints -}}
	 def {{ $endpoint.Name }}(self, msg: {{ $endpoint.RequestMsg }}) -> {{ $endpoint.ResponseMsg }}:
		"""{{ $endpoint.Description }}"""
		self._send("{{ $endpoint.Name }}", asdict(msg))
		return {{ $endpoint.ResponseMsg }}(**self._receive())
	{{- end }}

	def _send(self, endpoint: str, msg: Dict):
		header = {
			"api_version": API_VERSION,
			"api_key": self._api_key,
			"endpoint": endpoint,
		}
		self._send_frame(self._serialize(header))
		self._send_frame(self._serialize(msg))

	def _receive(self) -> Dict:
		header = self._deserialize(self._receive_frame())
		if not header["success"]:
			raise ServerError(header["error"])
		return self._deserialize(self._receive_frame())

	def _send_frame(self, frame_data: str):
		frame_len = len(frame_data).to_bytes(4, byteorder="big")
		self._socket.sendall(frame_len)
		self._socket.sendall(frame_data)

	def _receive_frame(self) -> bytes:
		frame_len = int.from_bytes(self._socket.recv(4), byteorder="big")
		return self._socket.recv(frame_len)

	@staticmethod
	def _serialize(msg: Dict) -> bytes:
		return json.dumps(msg).encode("utf8")

	@staticmethod
	def _deserialize(data: bytes) -> Dict:
		return json.loads(data.decode("utf8"))


_DEFAULT_CLIENT = None

def default_client() -> Client:
	"""Return a shared client. """
	global _DEFAULT_CLIENT
	if _DEFAULT_CLIENT is None:
		api_addr = os.environ["API_ADDRESS"]
		api_key = os.environ["API_KEY"]
		_DEFAULT_CLIENT = Client(api_addr, api_key)
	return _DEFAULT_CLIENT


@dataclass
class ServerError(Exception):
	"""The server responded with an error."""
	msg: str

{{ range $msg := .Spec.Messages }}
@dataclass
class {{ $msg.Name }}:
	"""
	{{ $msg.Description }}
	{{ if $msg.Fields }}
	Fields:
	{{ range $field := $msg.Fields }}
		{{ $field.Name }} ({{ $field.Type }}): {{ $field.Description }}
	{{- end }}
	{{- end }}
	"""
	{{ if $msg.Fields }}
	{{ range $field := $msg.Fields }}
	{{ $field.Name }}: {{ $field.Type | PythonType }} {{ if FieldHasDefault $field }}= {{ $field.Default | PythonValue }}{{ end }}
	{{ end }}
	{{ else }}
	pass
	{{ end }}
{{ end }}
`

	tmplFuncs := template.FuncMap{
		"PythonType":      PythonType,
		"PythonValue":     PythonValue,
		"FieldHasDefault": FieldHasDefault,
	}

	tmpl, err := template.New("client").Funcs(tmplFuncs).Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.New()")
	}

	return spec.generate(path, tmpl)
}

func (spec *ApiSpec) generate(path string, tmpl *template.Template) error {
	f, err := os.Create(path)
	if err != nil {
		return errors.Wrapf(err, "os.Create()")
	}
	defer f.Close()

	return tmpl.Execute(f, map[string]interface{}{
		"Spec": spec,
	})

}

func FieldHasDefault(f Field) bool {
	return f.Default != nil
}

func GoSymbol(s string) string {
	if len(s) == 0 {
		return s
	}

	// Replace underscores with spaces (we'll remove the spaces later).
	s = strings.ReplaceAll(s, "_", " ")

	// Capitalize the first letter of each word.
	s = strings.Title(s)

	// Remove the spaces.
	s = strings.ReplaceAll(s, " ", "")

	return s
}

func GoType(fieldType FieldType) string {
	switch fieldType {
	case FieldTypeString:
		return "string"
	case FieldTypeBool:
		return "bool"
	default:
		log.Fatalf("Unrecognized type: %s", fieldType)
		return ""
	}
}

func GoJsonTag(name string) string {
	return fmt.Sprintf("`json:\"%s\"`", name)
}

func PythonType(fieldType FieldType) string {
	switch fieldType {
	case FieldTypeString:
		return "str"
	case FieldTypeBool:
		return "bool"
	default:
		log.Fatalf("Unrecognized type: %s", fieldType)
		return ""
	}
}

func PythonValue(value interface{}) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%#v", v)
	case bool:
		if v {
			return "True"
		} else {
			return "False"
		}
	default:
		log.Fatalf("Unrecognized type for value: %v", value)
		return ""
	}
}
