// This file is generated by gen.go.  DO NOT EDIT.

package rpc

import (
	"encoding/json"
	"log"

	"github.com/pkg/errors"
)

// TaskBroker translates RPC requests/responses to executable tasks.
// It implements AsyncExecutor so a server can schedule tasks for asynchronous execution.
// It also implements TaskSource so tasks can be retrieved and executed.
type TaskBroker struct {
	taskChan chan Task
}

// NewTaskBroker creates a new task broker.
func NewTaskBroker() *TaskBroker {
	return &TaskBroker{
		taskChan: make(chan Task, 1),
	}
}

// ApiVersion returns the API version supported by the broker.
// All requests sent to the broker MUST conform to this API version.
// This implements AsyncExecutor#ApiVersion().
func (e *TaskBroker) ApiVersion() string {
	return "c1b64035ee710af0c85d3cfee7b56d80"
}

// ExecuteAsync implements AsyncExecutor#ExecuteAsync().
func (e *TaskBroker) ExecuteAsync(endpoint string, data []byte) (chan []byte, error) {
	switch endpoint {
	case "set_syntax":
		var msg SetSyntaxMsg
		if err := json.Unmarshal(data, &msg); err != nil {
			return nil, errors.Wrapf(err, "json.Unmarshal()")
		}

		replyMsgChan := make(chan OpResultMsg, 0)
		task, err := NewSetSyntaxTask(msg, replyMsgChan)
		if err != nil {
			return nil, errors.Wrapf(err, "NewSetSyntaxTask()")
		}

		replyChan := make(chan []byte, 0)
		go func() {
			defer close(replyChan)
			replyMsg := <-replyMsgChan
			replyData, err := json.Marshal(replyMsg)
			if err != nil {
				log.Printf("Could not serialize reply msg: %v\n", err)
				return
			}
			replyChan <- replyData
		}()

		e.taskChan <- task
		return replyChan, nil
	case "profile_memory":
		var msg ProfileMemoryMsg
		if err := json.Unmarshal(data, &msg); err != nil {
			return nil, errors.Wrapf(err, "json.Unmarshal()")
		}

		replyMsgChan := make(chan OpResultMsg, 0)
		task, err := NewProfileMemoryTask(msg, replyMsgChan)
		if err != nil {
			return nil, errors.Wrapf(err, "NewProfileMemoryTask()")
		}

		replyChan := make(chan []byte, 0)
		go func() {
			defer close(replyChan)
			replyMsg := <-replyMsgChan
			replyData, err := json.Marshal(replyMsg)
			if err != nil {
				log.Printf("Could not serialize reply msg: %v\n", err)
				return
			}
			replyChan <- replyData
		}()

		e.taskChan <- task
		return replyChan, nil
	case "quit":
		var msg EmptyMsg
		if err := json.Unmarshal(data, &msg); err != nil {
			return nil, errors.Wrapf(err, "json.Unmarshal()")
		}

		replyMsgChan := make(chan OpResultMsg, 0)
		task, err := NewQuitTask(msg, replyMsgChan)
		if err != nil {
			return nil, errors.Wrapf(err, "NewQuitTask()")
		}

		replyChan := make(chan []byte, 0)
		go func() {
			defer close(replyChan)
			replyMsg := <-replyMsgChan
			replyData, err := json.Marshal(replyMsg)
			if err != nil {
				log.Printf("Could not serialize reply msg: %v\n", err)
				return
			}
			replyChan <- replyData
		}()

		e.taskChan <- task
		return replyChan, nil

	default:
		return nil, errors.New("Invalid endpoint")
	}
}

// TaskChan implements TaskSource#TaskChan().
func (e *TaskBroker) TaskChan() chan Task {
	return e.taskChan
}
