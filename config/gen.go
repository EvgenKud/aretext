// +build ignore

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

var inputPath string
var outputPath string

func main() {
	flag.StringVar(&inputPath, "inputPath", "", "Input JSON spec of configuration fields")
	flag.StringVar(&outputPath, "outputPath", "", "Output path for config implementation")
	flag.Parse()

	if len(inputPath) < 1 {
		log.Fatalf("Must specify inputPath\n")
	}

	if len(outputPath) < 1 {
		log.Fatalf("Must specify outputPath\n")
	}

	fmt.Printf("Generating config implementation at '%s' from '%s'\n", outputPath, inputPath)

	fields, err := loadSpecFields(inputPath)
	if err != nil {
		log.Fatalf("Could not load spec from '%s': %v\n", inputPath, err)
	}

	err = writeConfigImpl(outputPath, fields)
	if err != nil {
		log.Fatalf("Could not write config impl to '%s': %v\n", outputPath, err)
	}
}

type SpecField struct {
	Name        string          `json:"name"`
	Type        string          `json:"type"`
	Validators  []SpecValidator `json:"validators"`
	Default     interface{}     `json:"default"`
	Description string          `json:"description"`
}

type SpecValidator struct {
	Name string        `json:"name"`
	Args []interface{} `json:"args"`
}

func FormatSpecValidator(v SpecValidator) string {
	var sb strings.Builder

	sb.WriteString(v.Name)
	sb.WriteRune('(')
	for i, arg := range v.Args {
		if i > 0 {
			sb.WriteRune(',')
		}
		sb.WriteString(fmt.Sprintf("%v", arg))
	}
	sb.WriteRune(')')

	return sb.String()
}

func loadSpecFields(path string) ([]SpecField, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, errors.Wrapf(err, "os.Open")
	}
	defer f.Close()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, errors.Wrapf(err, "ioutil.ReadAll")
	}

	var fields []SpecField
	err = json.Unmarshal(data, &fields)
	if err != nil {
		return nil, errors.Wrapf(err, "json.Unmarshal")
	}

	return fields, nil
}

func writeConfigImpl(path string, fields []SpecField) error {
	f, err := os.Create(path)
	if err != nil {
		return errors.Wrapf(err, "os.Create")
	}
	defer f.Close()

	tmplStr := `// This file is generated by gen.go.  DO NOT EDIT.
package config

import (
	"fmt"

	"github.com/pkg/errors"
)

// Config is a configuration for the editor.
type Config struct {
	{{ range .SpecFields }}
	// {{ .Description }}
	{{ .Name }} {{ .Type }}
	{{ end }}
}

{{ range .SpecFields -}}
const Default{{ .Name }} = {{ printf "%#v" .Default }}
{{ end }}

// DefaultConfig constructs a configuration with default values.
func DefaultConfig() Config {
	return Config{
		{{ range .SpecFields -}}
		{{ .Name }}: {{ printf "%#v" .Default }},
		{{ end }}
	}
}

// Apply overrides config values from fields set on a partial config.
func (c *Config) Apply(o PartialConfig) {
	{{ range .SpecFields }}
	if o.{{ .Name }} != nil {
		c.{{ .Name }} = *o.{{ .Name }}
	}
	{{ end }}
}

// ToPartial converts the config to a partial config.
func (c Config) ToPartial() PartialConfig {
	return PartialConfig{
		{{ range .SpecFields -}}
		{{ .Name }}: &c.{{ .Name }},
		{{ end }}
	}
}

// PartialConfig is a configuration with a subset of fields.
type PartialConfig struct {
	{{ range .SpecFields -}}
	{{ .Name }} *{{ .Type }}
	{{ end }}
}

// Validate checks that all fields in the partial config are valid.
func (c PartialConfig) Validate() error {
	{{ range $f := .SpecFields }}
	{{ range $v := $f.Validators }}
	if c.{{ $f.Name }} != nil {
		valid := {{ $v.Name }}(
			*c.{{ $f.Name }},
			{{ range $a := $v.Args -}}
			{{ $a }},
			{{ end }}
		)
		if !valid {
			msg := fmt.Sprintf("field %s failed validator %s", "{{ $f.Name }}", "{{ FormatSpecValidator $v }}")
			return errors.New(msg)
		}
	}
	{{ end }}
	{{ end }}
	return nil
}
`

	tmpl := template.New("config").Funcs(map[string]interface{}{
		"FormatSpecValidator": FormatSpecValidator,
	})

	tmpl, err = tmpl.Parse(tmplStr)
	if err != nil {
		return errors.Wrapf(err, "template.Parse")
	}

	return tmpl.Execute(f, map[string]interface{}{
		"SpecFields": fields,
	})
}
